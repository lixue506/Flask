#  SQLAlchemy

> - 特点
>
>   - 无需ORM
>
>     由组建Core和ORM组成。Core本身就是一个功能齐全的**SQL抽象工具包**，它为各种DBAPI( db API )实现和行为提供了一个平滑的抽象层，以及一个允许通过生成Python表达式表达SQL语言的SQL表达式语言。可以发出DDL语句以及内省现有模式的模式表示系统，以及允许将Python类型映射到数据库类型的类型系统，使系统更加完善。然后，对象关系映射器是一个基于Core构建的可选包。许多应用程序都是在Core上严格构建的，使用SQL表达式系统提供对数据库交互的简洁和精确控制。
>
>     
>
>   - 成熟，高性能的建筑
>
>     经过七年不断的开发，分析和重构，开发出了一个高性能，高精度，在测试中得到很好覆盖并在数千个环境中部署的工具包。几乎所有主要组件都在其第二次或第三次完整迭代中，SQLAlchemy 0.6的速度大约是几年前的0.4版本的两倍，0.7和0.8版本继续改进。它的原始执行速度与同类工具相比具有竞争力，并且高级ORM功能（如工作单元，内存中集合，通过连接或辅助子选择的集合的急切加载）以及其他优化允许SQLAlchemy的ORM发出更少，更高效的查询。任何以前的版本。
>
>     
>
>   - DBA批准
>
>     构建符合DBA的要求，包括使用手动优化的语句交换生成的SQL，使用工作单元模式完全使用所有文字值的绑定参数，完全事务化和批量数据库写入。所有对象关系模式都是围绕使用适当的引用完整性而设计的，而外键是其使用的一个组成部分。
>
>     
>
>   - 非自以为是
>
>     SQLAlchemy将最高价值放在不妨碍数据库和应用程序架构的方面。与许多工具不同，它 **从不** “生成”模式（不要与发布用户定义的[DDL](http://en.wikipedia.org/wiki/Data_Definition_Language)相混淆），或者依赖于任何类型的命名约定。SQLAlchemy尽可能支持最广泛的数据库和架构设计。
>
>     
>
>   - **工作单位**
>
>     工作单元系统是SQLAlchemy的对象关系映射器（ORM）的核心部分，它将待处理的插入/更新/删除操作组织到队列中，并在一个批处理中将它们全部刷新。为了实现这一点，它对队列中的所有已修改项执行拓扑“依赖性排序”，以便遵循行间依赖性，并将冗余语句组合在一起，有时可以进一步对其进行批处理。这样可以实现最高的效率和事务安全性，并最大限度地减少死锁的可能性。模仿[Fowler的“工作单元”模式](http://martinfowler.com/eaaCatalog/unitOfWork.html)以及 [Hibernate](http://hibernate.org/)，Java领先的对象关系映射器。
>
>     
>
>   - **基于功能的查询构造**
>
>     基于函数的查询构造允许通过Python函数和表达式构建SQL子句。可能的全部范围包括布尔表达式，运算符，函数，表别名，可选子查询，插入/更新/删除语句，相关更新，选择和`EXISTS`子句，`UNION` 子句，内部和外部联接，绑定参数以及文字的自由混合表达式中的文本。构造表达式可编译为特定于任何数量的供应商数据库实现（例如PostgreSQL或Oracle），由实现提供的“方言”和“编译器”的组合确定。
>
>     
>
>   - **模块化和可扩展**
>
>     SQLAlchemy的不同部分可以独立使用。连接池，SQL语句编译和事务服务等元素可以相互独立使用，也可以通过各种插件点进行扩展。集成的事件系统允许在超过50个交互点注入自定义代码，包括核心语句执行，模式生成和内省，连接池操作，对象关系配置，持久性操作，属性变异事件和事务阶段。可以无缝地构建和集成新的SQL表达式元素和自定义数据库类型。
>
>     
>
>   - 单独的映射和类设计
>
>     ORM标准化了一个“声明式”配置系统，该系统允许构建与其映射到的表元数据内联的用户定义类，与大多数其他对象关系工具提供的方式相同。但是，这个系统是完全可选的 - 在其核心，ORM将用户定义的类，关联的表元数据以及两者的映射完全分开。通过使用该`mapper()`函数，可以将任意Python类映射到数据库表或视图。映射类还保留了可串行化（酸洗），以便在各种缓存系统中使用。
>
>     
>
>   - **热切加载和缓存相关对象和集合**
>
>     ORM在加载后缓存对象之间的集合和引用，因此不需要在每次访问时发出SQL。热切加载功能允许通过集合和引用链接的对象的整个图形加载少量或仅一个查询，可在每个映射或每个查询的基础上配置到确切的语句计数，而不需要更改现有查询。ORM需要为集合中的所有对象发出单独的语句的“N + 1”问题在SQLAlchemy中已成为过去。
>
>     
>
>   - 复合（多列）主键
>
>     在SQLAlchemy中，主键和外键表示为列集; 真正的复合行为是从头开始实施的。ORM对有意义的（非代理）主键具有工业强度支持，包括与ON UPDATE CASCADE的可变性和兼容性，以及对其他常见复合PK模式的明确支持，例如“关联”对象（与多对多关系）每个协会附加的额外意义）。
>
>     
>
>   - 自引用对象映射
>
>     ORM支持自引用映射。可以使用适当的级联创建，保存和删除邻接列表结构，除了非自引用结构之外没有代码开销。可以调整任何深度的自引用结构的加载，以通过具有一系列连接（即，joinload）的单个语句递归地加载集合，或者通过多个语句来加载集合，其中每个语句以不同的深度加载完整的记录集（即subqueryload）。使用“更新后”功能本身也支持具有相互依赖的外键对的表的持久性（即“许多x”/“一个特定的x”）。
>
>     
>
>   - **继承映射**
>
>     显式支持可用于单表，具体表和连接表继承。所有三种样式都支持多态加载（即，返回多个后代类型的对象的查询）。可以优化每个的加载，使得仅使用一次往返来完全加载多态结果集。
>
>     
>
>   - **原始SQL语句映射**
>
>     SQLA的对象关系查询工具可以容纳原始SQL语句以及普通结果集，并且可以使用与任何其他ORM操作相同的方式从这些结果生成对象实例。您或您的DBA可以编写的任何超优化查询，您可以在SQLAlchemy中运行，只要它返回行集中的预期列，您就可以从中获取对象。也可以使用表示多种对象的语句，结果作为命名元组接收，或者将依赖对象路由到父对象的集合中。
>
>     
>
>   - 数据的预处理和后处理
>
>     类型系统允许在绑定参数和结果集级别进行数据的预处理和后处理。用户定义的类型可以与内置类型自由混合。可以使用通用类型以及特定于SQL的类型。
>
>     
>
>   - 支持的平台
>
>     SQLAlchemy通过最新的3.x版本支持Python 2.5。其他支持的平台包括Jython和Pypy。
>
>     
>
>   - 支持的数据库
>
>     SQLAlchemy包括SQLite，Postgresql，MySQL，Oracle，MS-SQL，Firebird，Sybase等方言，其中大多数支持多个DBAPI。其他方言作为外部项目发布。 使用每个特定数据库需要相应的[DB-API 2.0](http://www.python.org/dev/peps/pep-0249/)实现（或者有时是几个可用的实现之一）。[查看当前的DBAPI支持](https://www.sqlalchemy.org/docs/dialects/)



```c
    ORM : 对象-关系映射（Object/Relation Mapping，简称ORM），是随着面向对象的软件开发方法发展而产生的。面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。
```



